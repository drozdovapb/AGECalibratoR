
## Function 'DNALadderRun' takes an Optical Density Profile (ODP) of DNA ladder and several arguments; returns positions of peaks. 
## The search of peaks is based on deconvolution method.
## Argument:
## background --- integer or numeric value, which will be substracted from an ODP of DNA ladder;
## ladder --- vector of integer or numeric values, corresponding to ODP of DNA ladder;
## sigma --- sigma of searched peaks;
## threshold --- threshold value in % for selected peaks, peaks with amplitude less than threshold*highest_peak/100 are ignored.

DNALadderRun <- function(background, ladder, sigma = 5, threshold = 30){
  OD_ladder = ladder - background
  OD_ladder[OD_ladder < 0] <- 0 # removing of negative values
  
  peaks = SpectrumSearch(OD_ladder, sigma=sigma, threshold=threshold, background= TRUE,
                         iterations=13, markov=FALSE, window=1) # function from 'Peaks' package, which search peaks
  output = peaks$pos
  return(sort(output))
}




## Function 'DNALadderPlot' takes an Optical Density Profile (ODP) of DNA ladder, backgroung value and positions of peaks, calculated by the 'DNALadderRun' function; returns plot of ODP with peaks marked. 
## Argument:
## background --- integer or numeric value, which will be substracted from an ODP of DNA ladder;
## ladder --- vector of integer or numeric values, corresponding to ODP of DNA ladder;
## peaks --- vectors of numeric values, calculated by the 'DNALadderRun' function, corresponnding to the peaks in ODP. 

# coord_flip and scale_x_reverse commented by Yury (fanciness testing)
DNALadderPlot <- function(background, ladder, peaks){
  OD_ladder = ladder - background
  forexpand <- max(OD_ladder)
  peaks_kb = ifelse(is.na(peaks$names), NA, as.numeric(peaks$names) * 1000)
  l <- list(x = 1:length(OD_ladder), y = OD_ladder, peaks = peaks$pos, lbl = as.character(peaks_kb))
  
  max.length <- max(sapply(l, length))
  l <- lapply(l, function(v) {c(v, rep(NA, max.length - length(v)))})
  
  forplotting <- as_data_frame(l) # transforming ODP vector into the table with x and y values
  ## plot the ODP from the table, add lines, corresponding to the peak values.
  p <- ggplot(data = forplotting, aes(y = y, x = x)) + 
    geom_line() + coord_flip() +
    scale_x_reverse() + 
    geom_vline(mapping = aes(xintercept = as.numeric(peaks)), linetype = "dotted", col='red', lwd=0.85) +
    geom_text(mapping = aes(x = peaks, label = lbl, y = 250), na.rm = T, size = 5) +
    geom_vline(xintercept = 1) +
    geom_line() +
    xlab("px") + ylab("OD") +
    expand_limits(y = c(NA, 262)) + 
    theme_bw(base_size = 14)
  return(p)
}


## Function 'ODToSample' takes an Optical Density Profile (ODP) of protein sample and transform it to the pseudosample. 
## The values of runs (pixels) is multiplied by correspoding values of ODP.
## Arguments:
## background --- integer or numeric vector, corresponding to the ODP of empty line;
## protein --- integer or numeric vector, corresponding to the ODP of line with protein sample.

ODToSample <- function(background, protein){
  tmp = round(as.numeric(protein) - as.numeric(background), 0) # substraction of the background signal
  tmp[tmp < 0] <- 0 # removing of negative values
  sample =  rep(1:length(protein), tmp) # creating of pseudosample
  return(sample)
}

## Function 'MWCalculator' takes a table with Optical Density Profiles (ODPs) of protein samples and DNA ladder and calculate corresponding pseudosamples of molecular weight of proreins. 
## Arguments:
## data --- table with Optical Density Profiles (ODPs) of protein samples and DNA ladder, the input table for the App;
## background --- name of the column in the table, corresponding to the background signal of western blotting (empty line);
## model --- regression model for the conversion of Runs (px) into MM (Da), calculated by the 'RunToSizeModel' fuction; 
## excluded --- vectors of colum names, which will be excluded from the analysis (actually the name of column with ODP of DNA ladder).

## Function 'exactMW' takes: length of the molecule in bp and rate of GC pairs;
## returns MW of the molecule ##not used without TEM calibration
exactMW <- function(L, GC_rate = 0.5){
  return((L*GC_rate*(289.2 + 329.2)) + (L*(1-GC_rate)*(313.2 + 304.2)) + 2 * 79 )
}

## Function 'ConvertKbp2MW' takes a length of dsDNA in kilobase pairs and returns its molecular weights in Da.
## Formula from https://www.thermofisher.com/ru/ru/home/references/ambion-tech-support/rna-tools-and-calculators/dna-and-rna-molecular-weights-and-conversions.html
ConvertKbp2MW <- function(x){
  output <- 2 * x * 1000 * 303.7 + 2 * 79.0
  return(output)
}

## Function 'percentilesCalculator' takes a table, generated by the 'MWCalculator' function and transforms it to the table with percentile values (0 to 100) describing destribution of MWs of different samples. 

percentilesCalculator <- function(data){
  output <- data.frame(percentiles = 0:100)
  for(sample in levels(data$sample)){
    tmp <- quantile(x = data[data$sample == sample, "MW"], probs = seq(0,1,0.01)) #corrected percentile problem??
    output <- cbind(output, round(tmp,2))
    names(output)[length(names(output))] <- sample
  }
  print(output)
  return(output)
}


## Function 'PxToMobility' takes: coordinates of DNA ladder peaks, conditions of AGE (time (t in seconds), V, distance between electrodes (d in meters)) 
## and number of meters in 1 px (mppx (meter per pixel), m/px);
## returns modilities of the ladders. mu = (px * mppx * d)/(V * t)

PxToMobility <- function(px, t, V, d, mppx){
  return((px * mppx * d)/(V * t)) 
}


## Function 'Mu2Length' takes: mobilities of molecules (mu) and the parameters of the model(mul, mus, gamma);
## returns Lenght of the molecules in base pairs
Mu2Length <- function(mu, mul, mus, gamma){
  Length = gamma * (log(1/mul - 1/mus) - log(1/mul - 1/mu))
  return(Length)
}

## Function 'Run2LengthModel' takes: data frame(df) with lengths of the DNA ladder (kb) and correspoding mobilities (mu);
## returns list of the parameters of the model(mul, mus, gamma)

Run2LengthModel <- function(df, Tgel = 1.5){
  ## calculate start parameters for regression model
  gamma_start = (2.78 * Tgel + 7.49) * 1000
  mul_start = 1.99 * exp(-1.59 * Tgel)
  mus_start = -0.58 * Tgel + 3.56
  
  print(df)
  
  ## calculate regression model
  model <- nls(formula = 1/mu ~ 1/mul - (1/mul - 1/mus)*exp(-kb/gamma), data = df, 
               start = list(mul = mul_start * 10 ** -8, mus = mus_start * 10 ** -8, gamma = gamma_start), 
               control = nls.control(maxiter = 100, minFactor = 0.0000001, warnOnly = T))
  coefs <- coef(model)
  mul = coefs[1]
  mus = coefs[2]
  gamma = coefs[3]
  
  return(list(mul = mul, mus = mus, gamma = gamma))
}


##
MWCalculator <- function(data, background, model, excluded, t, V, d, mppx){
  
  sample <- character() # empty vector for sample names 
  MW <- numeric() # empty vector to collect the calculated MWs of proteins
  
  for(name in names(data)){ # for loop for the calculation across all columns in the input table, except excluded
    if(!(name %in% excluded)){
      px_sample <- ODToSample(background = data[,background], data[,name])
      
      mu_sample <- PxToMobility(px = px_sample, t, V, d, mppx) ## replace t, V, d and mppx for inputs)
      l_sample <- Mu2Length(mu_sample, model$mul, model$mus, model$gamma)
      l_sample <- l_sample[l_sample > 0 & !is.na(l_sample)]
      mw_sample <- exactMW(L = l_sample, GC_rate = 0.5)

      MW <- c(MW, mw_sample/1000)
      sample <- c(sample, rep(x = name, times = length(mw_sample)))    }
  }
  return(data.frame(sample, MW))
}


RunToMW <- function(Run, model, t, V, d, mppx){
  
  mu_sample <- PxToMobility(px = Run, t, V, d, mppx) ## replace t, V, d and mppx for inputs)
  l_sample <- Mu2Length(mu_sample, model$mul, model$mus, model$gamma)
  l_sample <- l_sample[l_sample > 0 & !is.na(l_sample)]
  mw_sample <- exactMW(L = l_sample, GC_rate = 0.5)
  if(length(mw_sample)==0){return(NA)}
  else{return(round(mw_sample/1000,3))}
}

##MainPeak is a function to extract the position of the main peak in the data
##Help here needed! Can't get spectrumsearch working ;( 
MainPeak <- function(x, sigma){
  #SpectrumSearch(x, sigma=20, threshold=20, background=TRUE, iterations=13, markov=FALSE, window=1)$pos[1]
  out <- tryCatch(
    {SpectrumSearch(as.numeric(x), sigma=sigma, threshold=10, background= TRUE, iterations=13, markov=FALSE, window=1)$pos[1]},
    error = function(cond){return(NA)}
  )
  #print(peak))
  return(out)
  }
